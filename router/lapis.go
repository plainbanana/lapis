package router

import (
	"bufio"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"path"
	"strings"
	"syscall"
	"time"

	"github.com/djherbis/stream"
	"github.com/gin-gonic/gin"
	"github.com/plainbanana/lapis/app"
	"github.com/plainbanana/lapis/entities"
)

var jst = time.FixedZone("Asia/Tokyo", 9*60*60)

// Stream is ffmpeg streamer
func Stream(c *gin.Context) {
	b64URL := c.Param("OriginURL")
	byteURL, err := base64.StdEncoding.DecodeString(b64URL)
	if err != nil {
		log.Println(err)
	}

	ffmpeg := os.Getenv("FFMPEG_BIN")
	if ffmpeg == "" {
		ffmpeg = "ffmpeg"
	}

	// get service id
	var serviceID string
	input := string(byteURL)
	if test := os.Getenv("TEST_INPUT"); test != "" {
		input = test
		serviceID = "26624"
	} else {
		inputParsed, _ := url.Parse(input)
		serviceID = strings.Split(inputParsed.Path, "/")[6]
		log.Println(input)
	}

	base := "http://" + os.Getenv("MIRAKURUN_IP") + ":" + os.Getenv("MIRAKURUN_PORT") + "/api/programs"
	if os.Getenv("MIRAKURUN_HTTPS") == "true" {
		base = "https://" + os.Getenv("MIRAKURUN_IP") + ":" + os.Getenv("MIRAKURUN_PORT") + "/api/programs"
	}
	log.Println(base)

	// get program from mirakurun
	// TODO: xmltv should contain dualmonostereo info
	req, _ := http.NewRequest("GET", base, nil)
	q := req.URL.Query()
	q.Add("serviceId", serviceID)
	req.URL.RawQuery = q.Encode()
	client := new(http.Client)
	res, err := client.Do(req)
	if err != nil {
		log.Println(err)
	}
	defer res.Body.Close()
	var programs entities.MirakurunPrograms
	jsonDecoder := json.NewDecoder(res.Body)
	err = jsonDecoder.Decode(&programs)

	// find audio component type
	var isdualmonostereo bool = false
	cursor2 := time.Now().Add(5*time.Minute).UnixNano() / 1000000
	for _, v := range programs {
		if cursor2 > v.StartAt && cursor2 < v.StartAt+int64(v.Duration) {
			if v.Audio.ComponentType == 2 {
				isdualmonostereo = true
			}
		}
	}

	xmltv := app.ConvertEpgToXML()

	var subtitle string = os.Getenv("SUBTITLE_DIR")
	if subtitle == "" {
		log.Fatal("set SUBTITLE_DIR")
	}

	// search on air program cursor
	// TODO: handle program name collectly
	var tmpsubtitle string
	var lapisID string
	cursor := time.Now().Add(5 * time.Minute).Format(app.Xmldateformat)
	log.Println(cursor)
	for _, v := range xmltv.Programme {
		if v.Channel == serviceID {
			if cursor > v.Start && cursor < v.Stop {
				base := subtitle

				lapisID = strings.Split(v.Desc.Desc, "lapisID:")[1]
				fname := lapisID + "-" + v.Title.Title + "-" + fmt.Sprint(v.Start) + "-" + time.Now().In(jst).Format(time.RFC3339Nano)
				subtitle = path.Join(base, fname)
				log.Println("found!!!", v.Title.Title, v.Channel, lapisID)

				// b := base64.StdEncoding.EncodeToString([]byte(v.Name))
				fname = time.Now().Format(time.RFC3339Nano)
				tmpsubtitle = path.Join(base, fname)
			}
		}
	}

	// cmd := exec.Command(ffmpeg, "-re",
	// 	"-i", input, "-c:v copy -acodec ac3 -b:a 192k -f mpegts pipe:1",
	// 	"-vf -re -c:s webvtt", subtitle)

	// ffmpeg -re -i input -c:v copy -c:a copy -f mpegts pipe:1
	// -vf -re -c:s webvtt subtitle

	// cmd := exec.Command(ffmpeg, "-re",
	// 	"-fix_sub_duration",
	// 	"-i", input, "-c:v", "libx264",
	// 	"-s", "720x480", "-aspect", "16:9", "-vb", "3000k",
	// 	"-acodec", "ac3", "-b:a", "192k",
	// 	"-c:s", "webvtt",
	// 	"-f", "webm", "pipe:1")

	// cmd := exec.Command(ffmpeg, "-re",
	// 	"-fix_sub_duration",
	// 	"-i", input, "-c:v", "copy",
	// 	"-acodec", "ac3", "-b:a", "192k",
	// 	"-c:s", "mov_text",
	// 	"-movflags", "frag_keyframe+empty_moov+delay_moov",
	// 	"-f", "mp4",
	// 	"pipe:1")

	// cmd := exec.Command(ffmpeg, "-re",
	// 	"-fix_sub_duration",
	// 	"-i", input, "-c:v", "copy",
	// 	"-c:a", "copy",
	// 	"-c:s", "webvtt",
	// 	"-f", "mpegts", "pipe:1")

	// cmd := exec.Command(ffmpeg, "-re",
	// 	"-fix_sub_duration",
	// 	"-i", input, "-c:v", "copy",
	// 	"-acodec", "ac3", "-b:a", "192k",
	// 	"-c:s", "webvtt",
	// 	"-f", "matroska", "pipe:1")

	// https://unix.stackexchange.com/questions/28503/how-can-i-send-stdout-to-multiple-commands
	reqOriginStream, _ := http.NewRequest("GET", input, nil)
	resOriginStream, err := client.Do(reqOriginStream)
	if err != nil {
		log.Println("get Mirakurun stream err:", err)
	}
	defer resOriginStream.Body.Close()

	var ffmpegSubtitle *exec.Cmd

	// backgroud ffmpeg task
	if strings.Contains(subtitle, "[字]") {
		tmpsubtitle += ".mkv"
		// clearly contains subtitle
		// webvtt generated by ffmpeg does not support color(?)
		ffmpegSubtitle = exec.Command(ffmpeg,
			"-analyzeduration", "5MB",
			"-probesize", "5MB",
			"-fix_sub_duration",
			"-i", "pipe:0",
			"-c:v", "copy",
			"-acodec", "ac3", "-b:a", "192k",
			"-c:s", "webvtt",
			"-f", "matroska", tmpsubtitle)
	} else {
		tmpsubtitle += ".ass"
		// run default
		ffmpegSubtitle = exec.Command(ffmpeg,
			"-analyzeduration", "5MB",
			"-probesize", "5MB",
			"-fix_sub_duration",
			"-i", "pipe:0",
			"-c:s", "ass", "-f", "ass", tmpsubtitle)
	}

	ffmpegSubtitleStdin, _ := ffmpegSubtitle.StdinPipe()
	ffmpegSubtitle.Stdout = os.Stdout
	ffmpegSubtitle.Stderr = os.Stderr

	ffmpegSubtitle.SysProcAttr = &syscall.SysProcAttr{Setpgid: true}
	ffmpegSubtitle.Start()

	log.Println(ffmpegSubtitle.String())

	// defer func must declare before the command start
	defer func() {
		log.Println("post process start")
		// ffmpegSubtitle.Process.Kill()
		gpid, err := syscall.Getpgid(ffmpegSubtitle.Process.Pid)
		if err == nil {
			syscall.Kill(-gpid, 15)
		}
		ffmpegSubtitle.Wait()
		c.Request.Body.Close()
		log.Println("post process end")
	}()

	header := c.Writer.Header()
	header["Content-type"] = []string{"video/M2PT"}
	header["Server"] = []string{"lapis/" + entities.LapisVersion}
	header["Content-Disposition"] = []string{`attachment; filename=lapis.m2ts`}

	sw, err := stream.New("m2tsstream")
	if err != nil {
		log.Fatal(err)
	}

	// input stream
	go func() {
		log.Println("input m2ts stream")
		io.Copy(sw, resOriginStream.Body)
		log.Println("input m2ts stream destoroy")
		// sw.Close()
	}()

	waiterForSubtitleWriter := make(chan struct{})
	waiterForResponseBodyReader := make(chan struct{})

	// stdin ffmpeg subtitle
	go func() {
		r, err := sw.NextReader()
		if err != nil {
			log.Fatal(err)
		}
		defer r.Close()
		log.Println("ffmpeg stdin will start...")

		close(waiterForSubtitleWriter)
		io.Copy(ffmpegSubtitleStdin, r)
		ffmpegSubtitleStdin.Close()
		log.Println("ffmpeg stdin end")
	}()
	// go io.Copy(fp, ffmpegSubtitleStdout)

	// write to response body
	r, err := sw.NextReader()
	if err != nil {
		log.Fatal(err)
	}
	defer r.Close()

	log.Println("body write will start...")
	// if dual mono stereo
	if isdualmonostereo {
		log.Println("DUAL MONO STEREO")
		ffmpegDualMonoStereo := exec.Command(ffmpeg,
			"-re",
			"-analyzeduration", "2MB",
			"-probesize", "2MB",
			"-fix_sub_duration",
			"-dual_mono_mode", "main",
			"-i", "pipe:0",
			"-c:v", "copy",
			"-acodec", "ac3", "-b:a", "192k",
			"-c:s", "webvtt",
			"-f", "mpegts", "pipe:1")

		stdin, _ := ffmpegDualMonoStereo.StdinPipe()
		stdout, _ := ffmpegDualMonoStereo.StdoutPipe()
		ffmpegDualMonoStereo.Stdout = os.Stdout
		ffmpegDualMonoStereo.Stderr = os.Stderr
		ffmpegDualMonoStereo.SysProcAttr = &syscall.SysProcAttr{Setpgid: true}
		ffmpegSubtitle.Start()

		defer func() {
			log.Println("post process2 start")
			// ffmpegSubtitle.Process.Kill()
			gpid, err := syscall.Getpgid(ffmpegDualMonoStereo.Process.Pid)
			if err == nil {
				syscall.Kill(-gpid, 15)
			}
			ffmpegSubtitle.Wait()
			c.Request.Body.Close()
			log.Println("post process2 end")
		}()

		go func() {
			io.Copy(stdin, r)
			stdin.Close()
		}()
		io.Copy(c.Writer, stdout)
	} else {
		io.Copy(c.Writer, r)
	}
	close(waiterForResponseBodyReader)
	// <-waiterForResponseBodyReader
	log.Println("subtitle wait start...")

	// SIGINT
	gpid, err := syscall.Getpgid(ffmpegSubtitle.Process.Pid)
	if err == nil {
		syscall.Kill(-gpid, 2)
	}
	ffmpegSubtitle.Wait()
	stdout, err := ffmpegSubtitle.CombinedOutput()
	log.Println("progout", err, string(stdout))

	sw.Close()
	log.Println("end prog")

	if strings.Contains(subtitle, "[字]") {
		tmpfile, err := ioutil.TempFile("", "mergetmp")
		if err != nil {
			log.Fatal(err)
		}

		r, err := sw.NextReader()
		if err != nil {
			log.Fatal(err)
		}
		defer r.Close()

		defer os.Remove(tmpfile.Name())
		defer tmpfile.Close()

		io.Copy(tmpfile, r)
	}
	// if strings.Contains(subtitle, "[字]") {
	// 	r, err := sw.NextReader()
	// 	if err != nil {
	// 		log.Println("Err at concatsubtitle", err)
	// 	}
	// 	ffmpegConcatSubtitle := exec.Command(ffmpeg,
	// 		"-analyzeduration", "2MB",
	// 		"-probesize", "2MB",
	// 		"-fix_sub_duration",
	// 		"-dual_mono_mode", "main",
	// 		"-i", "pipe:0",
	// 		"-i", tmpsubtitle,
	// 		"-c:v", "copy",
	// 		"-acodec", "ac3", "-b:a", "192k",
	// 		"-c:s", "ass",
	// 		"-f", "matroska", tmpsubtitle+".mkv")

	// 	stdin, _ := ffmpegConcatSubtitle.StdinPipe()
	// 	ffmpegConcatSubtitle.Stdout = os.Stdout
	// 	ffmpegConcatSubtitle.Stderr = os.Stderr
	// 	ffmpegConcatSubtitle.SysProcAttr = &syscall.SysProcAttr{Setpgid: true}
	// 	ffmpegSubtitle.Start()

	// 	defer func() {
	// 		log.Println("post process2 start")
	// 		// ffmpegSubtitle.Process.Kill()
	// 		gpid, err := syscall.Getpgid(ffmpegConcatSubtitle.Process.Pid)
	// 		if err == nil {
	// 			syscall.Kill(-gpid, 15)
	// 		}
	// 		ffmpegSubtitle.Wait()
	// 		c.Request.Body.Close()
	// 		log.Println("post process2 end")
	// 	}()

	// 	go func() {
	// 		io.Copy(stdin, r)
	// 		stdin.Close()
	// 	}()
	// 	os.Remove(tmpsubtitle)
	// 	tmpsubtitle += ".mkv"
	// }

	if _, err := os.Stat(tmpsubtitle); err == nil {
		// if file contains "WEBVTT" only, remove
		if readAllLines(tmpsubtitle) > 1 {
			pos := strings.LastIndex(tmpsubtitle, ".")
			err = os.Rename(tmpsubtitle, subtitle+tmpsubtitle[pos:])
			if err != nil {
				log.Println(err)
			}
		} else {
			os.Remove(tmpsubtitle)
		}
	}
}

func readAllLines(filename string) int {
	fp, err := os.Open(filename)
	if err != nil {
		return 0
	}

	lines := 0

	scanner := bufio.NewScanner(fp)
	for scanner.Scan() {
		lines++
	}

	fp.Close()
	return lines
}
